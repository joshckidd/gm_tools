// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rolls.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createAggregateRoll = `-- name: CreateAggregateRoll :one
INSERT INTO aggregate_rolls (id, created_at, updated_at, string, result, username)
VALUES (
    gen_random_uuid()
    ,NOW()
    ,NOW()
    ,$1
    ,$2
    ,$3
)
RETURNING id, created_at, updated_at, string, result, username
`

type CreateAggregateRollParams struct {
	String   string `json:"string"`
	Result   int32  `json:"result"`
	Username string `json:"username"`
}

func (q *Queries) CreateAggregateRoll(ctx context.Context, arg CreateAggregateRollParams) (AggregateRoll, error) {
	row := q.db.QueryRowContext(ctx, createAggregateRoll, arg.String, arg.Result, arg.Username)
	var i AggregateRoll
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.String,
		&i.Result,
		&i.Username,
	)
	return i, err
}

const createRoll = `-- name: CreateRoll :one
INSERT INTO rolls (id, created_at, updated_at, string, result, individual_rolls, aggregate_roll_id, username)
VALUES (
    gen_random_uuid()
    ,NOW()
    ,NOW()
    ,$1
    ,$2
    ,$3
    ,$4
    ,$5
)
RETURNING id, created_at, updated_at, string, result, individual_rolls, aggregate_roll_id, username
`

type CreateRollParams struct {
	String          string    `json:"string"`
	Result          int32     `json:"result"`
	IndividualRolls string    `json:"individual_rolls"`
	AggregateRollID uuid.UUID `json:"aggregate_roll_id"`
	Username        string    `json:"username"`
}

func (q *Queries) CreateRoll(ctx context.Context, arg CreateRollParams) (Roll, error) {
	row := q.db.QueryRowContext(ctx, createRoll,
		arg.String,
		arg.Result,
		arg.IndividualRolls,
		arg.AggregateRollID,
		arg.Username,
	)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.String,
		&i.Result,
		&i.IndividualRolls,
		&i.AggregateRollID,
		&i.Username,
	)
	return i, err
}

const getAggregateRolls = `-- name: GetAggregateRolls :many
SELECT id, created_at, updated_at, string, result, username
FROM aggregate_rolls
WHERE username = $1
`

func (q *Queries) GetAggregateRolls(ctx context.Context, username string) ([]AggregateRoll, error) {
	rows, err := q.db.QueryContext(ctx, getAggregateRolls, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggregateRoll
	for rows.Next() {
		var i AggregateRoll
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.String,
			&i.Result,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolls = `-- name: GetRolls :many
SELECT id, created_at, updated_at, string, result, individual_rolls, aggregate_roll_id, username
FROM rolls
WHERE aggregate_roll_id = $1
`

func (q *Queries) GetRolls(ctx context.Context, aggregateRollID uuid.UUID) ([]Roll, error) {
	rows, err := q.db.QueryContext(ctx, getRolls, aggregateRollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Roll
	for rows.Next() {
		var i Roll
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.String,
			&i.Result,
			&i.IndividualRolls,
			&i.AggregateRollID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
